## 写递归算法的秘诀
- **明确函数的「定义」是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要跳入递归的细节**。
- **写树相关的算法，简单说就是，先搞清楚当前 `root` 节点「该做什么」以及「什么时候做」，然后根据函数定义递归调用子节点**
- 所谓「**该做什么**」就是让你想清楚写什么代码能够实现题目想要的效果，所谓「**什么时候做**」，就是让你思考这段代码到底应该写在前序、中序还是后序遍历的代码位置上。
- **把题目的要求细化，搞清楚根节点应该做什么，然后剩下的事情抛给前/中/后序的遍历框架就行了**，


## 算法实践
- 翻转二叉树，把整颗树镜像翻转
	- 思路：只要把二叉树上的每一个节点的左右子节点进行交换就完成了；可以在前序位置或者后序位置进行左右子节点的交换，但是中序位置不行。
	- 函数定义：输入一棵树的根节点，返回镜像翻转后的树根节点，base case 就是树为空的情况，先交换根节点的左右子节点，然后递归处理左右子树，最后返回翻转后的树根节点
- 填充二叉树节点的右侧指针
	- 思路：每个节点的左右子节点都要穿起来，还要连接跨父节点的两个相邻节点，既然要跨父节点，那么输入就得包含两个节点，设置两个参数，将该连起来的节点都连起来
	- 函数定义：输入两个节点，对两个节点做连接

- 将二叉树展开为链表
	- 思路：将root的左右子树分别拉平并记录为变量；将拉平后的左链表作为右子树；将拉平后的右链表接到右链表后面（这一步需要while循环找表尾）

- 构造最大二叉树
	- 思路：对于每个根节点，只需要找到当前 `nums` 中的最大值和对应的索引，然后递归调用左右数组构造左右子树即可。

- 通过前序和中序遍历结果构造二叉树
	- 思路：
		- 前序序列第一个值是根节点，
		- 根据该值，中序序列被分为左右两子树，
	- 函数定义：
		- 定义函数输入是两个序列，输出是根节点
		- 函数内递归调用，根据新的两个子序列构建左右子树
		- 函数内在后续位置将递归构建的左右子树链接到根节点后面

- 通过后序和中序遍历结果构造二叉树
- 通过前序和后序遍历结果构造二叉树（答案不唯一）

- 寻找重复的子树
	- 思路：
		- 对于任一节点，我想知道以我为根的这棵子树长啥样
		- 以其他节点为根的子树长啥样
		- 将见过的子树都存在集合，考虑每个节点的子树的时候都去查一下，遇到相同的说明有重复，没有重复就加入集合
		- 怎么描述子树（往集合中存什么）：二叉树的序列化 #todo




## todo
- [ ] 二叉树的序列化