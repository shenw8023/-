二叉树解题的思维模式分两类：
**1、是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现，这叫「遍历」的思维模式。
**2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。

无论使用哪种思维模式，你都需要思考：

**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

**快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历**，二叉树的算法思想的运用广泛，甚至可以说，只要涉及递归，都可以抽象成二叉树的问题。 ^211b36

**前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点**

- 前序位置是进入一个节点的时候，后序位置是离开一个节点的时候。

-  **二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着 [回溯算法核心框架](https://labuladong.gitee.io/algo/4/31/105/) 和 [动态规划核心框架](https://labuladong.gitee.io/algo/3/25/69/)**。

	- 文中举例分别用遍历的思路和分解问题的思路，使用递归解决 1.求二叉树最大深度；2.前中后序打印二叉树 #todo

综上，遇到一道二叉树的题目时的通用思考过程是：
**1、是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现。
**2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。
**3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做**。


你可以发现，前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的：


因为本文开头就说了前序位置是刚刚进入节点的时刻，后序位置是即将离开节点的时刻。
**但这里面大有玄妙，意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据**。
**那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了**。