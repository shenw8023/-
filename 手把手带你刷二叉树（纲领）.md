#attention 多多记忆每个大标题后面的总结部分

## 深入理解前中后序
- 二叉树遍历框架：
- 和遍历数组或者链表本质上没有区别
	- 迭代遍历数组：
	- 递归遍历数组：
	- 迭代遍历单链表：
	- 递归遍历单链表：

- 递归形式遍历的规律特点：
	- 二叉树没办法简单改写成迭代形式，所以一般二叉树的遍历框架都是指递归形式
	- 可以发现，只要是递归形式的遍历，都会有一个**前序和后序位置**，分别在**递归之前和之后**
	- 所谓**前序位置**，就是刚进入一个节点的时候，**后序位置**就是即将离开一个节点的时候
	- 处理的代码写在不同位置，代码执行的时机也不同
	- 举例：倒序打印一条单链表节点上的值：递归遍历单链表，在后序位置打印节点值
	
- 说回二叉树，不过是多了一个中序位置罢了

- 这里前中后序的理解：
	- 分别是是遍历二叉树过程中处理每一个节点的三个特殊时间点
	- 前序位置的代码在刚刚进入一个二叉树节点的时候执行；
	- 后序位置的代码在将要离开一个二叉树节点的时候执行；
	- 中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。
- 总结：
	- **二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的**。
	- 你只需要思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会对所有节点做相同的操作。



## 两种解题思路
### 1. 遍历一遍二叉树得到答案（对应回溯算法核心框架）

### 2. 分解问题计算答案（对应动态规划核心框架）

- 举例：
	- 求二叉树的最大深度：
		- 遍历思路：遍历一遍二叉树，用一个外部变量记录每个节点所在的深度，取最大值就得到最大深度。
		- 分解思路：一棵二叉树的最大深度可以通过**子树**的最大高度推导出来，整棵树的最大深度等于左右子树的最大深度取最大值，然后加上根节点自己。
			- *注意⚠️：为什么该思路的核心代码逻辑放在后序位置？因为要通过子树的最大高度推导出原树的最大高度，当然要利用递归函数的定义算出左右子树的最大深度，然后才能推出原树最大深度。*
	- 求二叉树前序遍历序列：
		- 遍历思路：[[代码#^d8949a|前序遍历框架]]
		- 分解思路：我们知道前序遍历的特点是，根节点的值排在首位，接着是左子树的前序遍历结果，最后是右子树的前序遍历结果；那就可以分解问题了：**一棵二叉树的前序遍历分解成了根节点和左右子树的前序遍历结果**。[[代码#^59a645|分解思路的前序遍历]]
	

## 解题思考过程总结：
- **是否可以通过遍历一遍二叉树得到答案**
- **如果不能的话，是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**


## 后序位置的特殊之处

^612df6

- 特点
	- 发现前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的
- 意义：
	- **意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据**。
- 举例：
	- 1、如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？
		- 思路：在函数参数中记录层参数，在前序位置打印该参数，每深入递归一次，该参数也递增一次。
	- 2、如何打印出每个节点的左右子树各有多少节点？
		- 思路：要打印子树的信息，只有后序位置才能做到，定义函数输入一棵二叉树，返回这棵树的节点总数；那么在后序位置就能递归调用，分别返回左右子树的节点数了。
	- 3、计算一棵二叉树的最长直径长度？
		- 思路：所谓二叉树的「直径」长度，就是任意两个结点之间的路径长度，每一条二叉树的「直径」长度，就是一个节点的左右子树的最大深度之和，注意应该把计算「直径」的逻辑放在后序位置，
- **总结：**
	- **只有后序位置才能通过返回值获取子树的信息**
	- **一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了**。
	- **遇到子树问题，首先想到的是给函数设置返回值，然后在后序位置做文章。**


## 层序遍历
- 二叉树题型主要是用来培养递归思维的，而层序遍历属于迭代遍历，借助队列实现 [[代码#^046ddd|宽度优先遍历]]
