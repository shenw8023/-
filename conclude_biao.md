
- [手把手刷链表算法——双指针](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-8f30d/shuang-zhi-0f7cc/)
    - 21. 合并两个有序链表
        - 用到了链表的算法题中是很常见的「虚拟头结点」技巧，也就是 dummy 节点
    - 86. 分隔链表
        - 注意断开连接
    - 23. 合并k个有序链表
        - heapq.heappush 稳定性问题，遇到相同值
            - 针对前两项挑战的一种解决方案是将条目保存为包含优先级、条目计数和任务对象 3 个元素的列表。 条目计数可用来打破平局，这样具有相同优先级的任务将按它们的添加顺序返回。 并且由于没有哪两个条目计数是相同的，元组比较将永远不会直接比较两个任务。  https://docs.python.org/zh-cn/3/library/heapq.html

    - 剑指 Offer 22. 链表中倒数第k个节点
        - 最后一个节点就是倒数第一个节点，完成后带进去试一下求倒数第一个节点，最后的时候，fast=None,slow=最后一个节点
    - 19. 删除链表的倒数第 N 个结点 
    - 876. 链表的中间结点
    - 160. 两个链表是否相交
    - 142. 入环节点 #[ ]


- [递归反转链表](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-8f30d/di-gui-mo--10b77/)
    - 206. 反转链表
    - 92. 反转链表 II

- [手把手刷数组算法——双指针](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-48c1d/shuang-zhi-fa4bd/)
    - 26. 删除**有序**数组中的重复项
        - 对有序数组去重，快慢指针，交换时slow要先走一步，然后交换元素，结果返回长度时候slow就要+1
    - 83. 删除**排序**链表中的重复元素
        - 对有序链表去重，快慢指针，交换时slow不需要先走一步，直接slow.next=fast
    - 27. 原地移除数组中值为val的元素
        - 快慢指针，在合适的时候，先赋值给slow，然后slow+=1，结果返回的时候slow就不要+1了，因为slow最后已经+1了
    - 167. 两数之和 II - 输入有序数组
        - 左右指针，注意题目要求的索引从1开始，输出的时候相应要+1
    - 344. 反转字符串
        - 左右指针
    - 5. 最长回文子串
        - 注意： **记得撤销最后一次循环，所以要+1，-1；又因为切片右闭，所以右边再+1** 

    - 283. 把所有零移动到数组末尾   

    - 总结：关于slow是先+1还是后+1，就带入考虑第一步的时候满足条件要不要交换就行了



- [二叉树纲领篇](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/dong-ge-da-334dd/)

    - 104. 二叉树的最大深度
        - 遍历的思路——对应回溯框架
        - 分解的思路——对应动态规划框架，递归
    - 144. 二叉树的前序遍历
        - 两种思路，两种写法
    - 543. 二叉树的直径
        - 后续位置顺便记录最大直径


- 动态规划
    - 322. 零钱兑换 
        - 自顶向下，构建dp函数
        - 自底向上，直接从base_base循环得到dp_table

    -      0-1背包问题
    - 416. 分割等和子集（子集背包问题）
    - 518. 零钱兑换 II （完全背包问题）
        - 注意物品数量无限带来的区别

    - 494. 目标和
        - 回溯方式
        - 带备忘录的递归方式
        - 变形为子集划分问题，即子集背包问题

    - 198. 打家劫舍1
    - 213. 打家劫舍 II
    - 337. 打家劫舍 III


- 总结：
    - **凡是在循环内用到next的节点，都要判断保证该节点本身不能是None，因为None是没有next属性的**


- 链表问题

- 86. 分隔链表
- 21. 合并两个有序链表
- 23. 合并 K 个升序链表
- 剑指Offer 22. 链表中倒数第k个节点
- 19. 删除链表的倒数第 N 个结点
- 876. 找链表的中间结点
- 142. 环形链表 II
- 160. 相交链表，找到交点
- 206. 反转单链表
- 92. 反转单链表Ⅱ, 反转从位置left到位置right 的链表节点 #TODO


- 双指针问题
- 344. 反转字符串
- 26. 删除有序数组中的重复项
- 27. 原地移除元素，不使用额外数组空间
- 283. 移除零到数组末尾
- 83. 删除排序链表中的重复元素




- nSum问题
- 1. 两数之和，无序数组，要求返回索引
    - 哈希表
- 167. 两数之和II - 输入有序数组
- 15. 三数之和
    - 注意重复双指针里面跳过重复元素，外层循环也要用last变量记录跳过重复
- nSum
    - 需要四个参数 (nums, n, start, target)


- 链表
- 25. K个一组反转链表
    - 前k个做反转以后，剩下的又变成原问题的子问题，把这两步连接起来
- 234. 判断是否为回文链表
    - 找到中点，把右半反转，在相向而行比较，注意奇数和偶数长度的区别

- 前缀和
- 303 实现数据类，能快速得到nums[left]到nums[right]之间的和
- 304 二维区域和检索 - 矩阵不可变


- 多维数组遍历
- 151 反转字符串中的单词
- 48 旋转图像，将一个矩阵顺时针旋转90度
- 54 螺旋矩阵 #TODO

- 非常规二分搜索
- 528. 按权重随机选择
- 1011. 在 D 天内送达包裹的能力 #TODO
- 410. 分割数组的最大值
- 875. 爱吃香蕉的珂珂
- 870. 优势洗牌


- 二叉树
- 114. 二叉树展开为链表，拉平二叉树
- 116. 填充每个节点的下一个右侧节点指针
- 226. 翻转二叉树
- 106. 根据中序与后序遍历构造二叉树
- 889. 根据前序和后序遍历构造二叉树
- 654. 构建最大二叉树
- 230. 二叉搜索树中第K小的元素
- 700. 二叉搜索树中的搜索一个目标数
- 98. 验证二叉搜索树 #TODO
- 797. 所有可能的路径


- 岛屿问题
- 200. 岛屿数量
    - 遍历，每找到一个岛，就要用dfs把跟他相连的区域都淹掉
- 1254. 统计封闭岛屿的数目
    - 先把边缘全淹掉，再统计岛数量
- 1020. 飞地的数量
    - 先淹掉边缘，然后遍历统计的时候不要再淹了
- 695. 岛屿的最大面积
    - 每递归淹掉一个岛，返回总共淹掉的面积，比较最大的面积
- 1905. 统计子岛屿
    -  先把2中肯定不是子岛的地方淹掉，剩下的区域都是子岛，计数
- 130. 被围绕的区域
    - 先用遍历棋盘的四边，用把那些与边界相连的 O 换成一个特殊字符，比如 #；然后再遍历整个棋盘完成要求



- 区间问题
- 1288. 删除被覆盖区间
- 56. 合并区间
- 986. 区间列表的交集
    - 相交的核心逻辑：if b2 >= a1 and b1<=a2:


- 42. 接雨水
- 11. 盛最多水的容器

