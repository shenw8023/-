## BST 特性
1. 对于 BST 的每一个节点 `node`，左子树节点的值都比 `node` 的值要小，右子树节点的值都比 `node` 的值大。
2. 对于 BST 的每一个节点 `node`，它的左侧子树和右侧子树都是 BST。
3. BST 的每个节点应该要小于右边子树的所有节点。
4. **BST 的中序遍历结果是有序的（升序）**
5. BST 的操作为什么这么高效？就拿搜索某一个元素来说，BST 能够在对数时间找到该元素的根本原因还是在 BST 的定义里，左子树小右子树大嘛，所以每个节点都可以通过对比自身的值判断去左子树还是右子树搜索目标值，从而避免了全树遍历，达到**对数级复杂度**。
6. [[代码#^4a3f5d|常用框架]]


## 题目
- 寻找二叉搜索树中第k小的元素
	- 思路：升序排序后，也就是找第k个元素
	- 用一个变量记录序号索引（初始为零），对每个节点来说，我们要在中序位置对序号索引递增，然后判断是否已经遍历到了要找的第k个索引，如果找到了就返回。
	- **更优方式**：要达到**对数级复杂度**才合理；要想找到排名为k的元素，关键在于**每个节点得知道他排第几**，这样我**才能通过比较知道要去左子树找还是右子树找**，所以要求每个节点维护额外的信息，记录以自己为根的这棵二叉树有多少节点。 

- BST转化累加树
	- 要求把每个节点转为原树中大于或等于这个节点的值之和
	- 思路：对于一个节点来说，**大于或等于它的节点都在右子树以及父节点**，所以如果能从大到小倒叙书写整个树，每个节点的新值都是已遍历的节点累加和
	- **从大到小倒叙遍历**，只要在中序遍历中调换一下左右子树的递归顺序

- 判断BST的合法性
	- 思路：**注意 BST 的每个节点应该要小于右边子树的所有节点**，所以对于每个节点，代码不能只检查他的左右孩子是否满足左小右大原则，而是整个左子树都要小于**节点值**，整个右子树都要大于**节点值**。通过使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点。
	- [[代码#^58547f|代码]]

- 在BST中搜索元素
	- 思路：利用其左小右大的特性，二分查找
	- [[代码#^b4fe35|代码]]


- 在BST中插入一个数
	- 思路：遍历就是找，涉及到改，直接在找的框架之上，添加改的操作，函数要返回TreeNode类型，并且对递归的调用返回值要进行接受
	- [[代码#^20fa6c|代码]]


- 在BST中删除一个数
	- 思路：框架跟插入操作一致，先找 再 改；但是找到目标节点以后要分情况考虑如何删除该节点才能不破坏BST的性质：
		1. 恰好是叶子结点，直接干掉
		2. 只有一个非空子节点，那么让该子节点接替自己的位置
		3. 有两个字节点，必须找到左子树中最大的那个节点或者右子树中最小的那个节点来接替自己
	- 第三种情况处理情况 3 时通过一系列略微复杂的链表操作交换 `root` 和 `minNode` 两个节点：**虽然可以，我们一般不会通过修改节点内部的值来交换节点。** 因为在实际应用中，BST 节点内部的数据域是用户自定义的，可以非常复杂，而 BST 作为数据结构（一个工具人），其操作应该和内部存储的数据域解耦，所以我们更倾向于使用指针操作来交换节点，根本没必要关心内部数据。
	- 代码需要仔细研究


- 不同的二叉搜索树，给一个正整数n，计算{1,2...n}这些值共有多少种不同BST
	- 思路：
		- 穷举问题，二叉树算法关键在于明确根节点需要做什么，按每一个数字都能作为根节点来枚举，取某个数为根节点，那么其左边的数列也要计算能构造多少棵BST（递归），其右边的数列能构造多少棵BST（递归），乘积就是以这个数为根节点的BST数量；
		- 存在重叠子问题，需要一个备忘录
	- [[代码#^727179|代码]]
	

- 构造出所有可能的BST
	- 思路：得到左右所有可能的BST后，遍历构造出当前根节点对应的BST，放入结果集
	- [[代码#^609e04|代码]]


## 总结
1. 如果当前节点会对下面的子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息。
2. 在二叉树递归框架之上，扩展出一套 [[代码#^4a3f5d|BST 代码框架]] 
3. 根据代码框架掌握了 BST 的增删查改操作。


